---
id: colliders
title: Colliders
sidebar_label: Colliders
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Colliders represent the geometric shapes that generate contacts and intersection events when they touch.
Attaching one or multiple colliders to a rigid body allow the rigid-body to be affected by contact forces.

## Creation and insertion
A collider is created by a `ColliderBuilder` structure that is based on the builder pattern. Then it needs
to be inserted into the `ColliderSet` that will be processed by the physics-pipeline, collision-pipeline, or
query-pipeline.

:::info
The following example shows most setters that can be called to customize the
collider being built. The input values are just random so using this example as-is will not
lead to a useful result.
:::

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
use na::{Vector2, Isometry2};
use rapier2d::geometry::{ColliderBuilder, ColliderSet, SharedShape};
use std::f32::consts::PI;

// The set that will contain our colliders.
let mut collider_set = ColliderSet::new();

// Builder for a ball-shaped collider.
let _ = ColliderBuilder::ball(0.5);
// Builder for a cuboid-shaped collider.
let _ = ColliderBuilder::cuboid(0.5, 0.2);
// Builder for a capsule-shaped collider. The capsule principal axis is the `x` coordinate axis.
let _ = ColliderBuilder::capsule_x(0.5, 0.2);
// Builder for a capsule-shaped collider. The capsule principal axis is the `y` coordinate axis.
let _ = ColliderBuilder::capsule_y(0.5, 0.2);
// Builder for a triangle-mesh-shaped collider.
let _ = ColliderBuilder::trimesh(vertices, indices);
// Builder for a heightfield-shaped collider.
let _ = ColliderBuilder::heightfield(heights, scale);
// Builder for a collider with the given shape.
let collider = ColliderBuilder::new(SharedShape::ball(0.5))
    // The collider translation wrt. the body it is attached to.
    // Default: the zero vector.
    .translation(vector![1.0, 2.0])
    // The collider rotation wrt. the body it is attached to.
    // Default: the identity rotation.
    .rotation(PI)
    // The collider position wrt. the body it is attached to.
    // Default: the identity isometry.
    .position(Isometry2::new(vector![1.0, 2.0], PI))
    // The collider density. If non-zero the collider's mass and angular inertia will be added
    // to the inertial properties of the body it is attached to.
    // Default: 1.0
    .density(1.3)
    // The friction coefficient of this collider.
    // Default: ColliderBuilder::default_friction() == 0.5
    .friction(0.8)
    // Whether this collider is a sensor, i.e., generate only intersection events.
    // Default: false
    .sensor(true)
    // All done, actually build the collider.
    .build();

// Insert the collider into the set.
let handle = collider_set.insert(collider);
// Or insert the collider into the set and attach it to a rigid-body.
let handle = collider_set.insert_with_parent(collider, rigid_body_handle, &mut rigid_body_set);
```

  </TabItem>
  <TabItem value="3D">

```rust
use na::{Vector3, Isometry3};
use rapier3d::geometry::{ColliderBuilder, ColliderSet, SharedShape};
use std::f32::consts::PI;

// The set that will contain our colliders.
let mut collider_set = ColliderSet::new();

// Builder for a ball-shaped collider.
let _ = ColliderBuilder::ball(0.5);
// Builder for a cuboid-shaped collider.
let _ = ColliderBuilder::cuboid(0.5, 0.2, 0.1);
// Builder for a capsule-shaped collider. The capsule principal axis is the `x` coordinate axis.
let _ = ColliderBuilder::capsule_x(0.5, 0.2);
// Builder for a capsule-shaped collider. The capsule principal axis is the `y` coordinate axis.
let _ = ColliderBuilder::capsule_y(0.5, 0.2);
// Builder for a capsule-shaped collider. The capsule principal axis is the `z` coordinate axis.
let _ = ColliderBuilder::capsule_z(0.5, 0.2);
// Builder for a triangle-mesh-shaped collider.
let _ = ColliderBuilder::trimesh(vertices, indices);
// Builder for a heightfield-shaped collider.
let _ = ColliderBuilder::heightfield(heights, scale);
// Builder for a collider with the given shape.
let collider = ColliderBuilder::new(SharedShape::ball(0.5))
    // The collider translation wrt. the body it is attached to.
    // Default: the zero vector.
    .translation(vector![1.0, 2.0, 3.0])
    // The collider rotation wrt. the body it is attached to.
    // Default: the identity rotation.
    .rotation(vector![0.0, PI, 0.0])
    // The collider position wrt. the body it is attached to.
    // Default: the identity isometry.
    .position(Isometry3::new(vector![1.0, 2.0, 3.0], vector![0.0, PI, 0.0]))
    // The collider density. If non-zero the collider's mass and angular inertia will be added
    // to the inertial properties of the body it is attached to.
    // Default: 1.0
    .density(1.3)
    // The friction coefficient of this collider.
    // Default: ColliderBuilder::default_friction() == 0.5
    .friction(0.8)
    // Whether this collider is a sensor, i.e., generate only intersection events.
    // Default: false
    .sensor(true)
    // All done, actually build the collider.
    .build();

// Insert the collider into the set.
let handle = collider_set.insert(collider);
// Or insert the collider into the set and attach it to a rigid-body.
let handle = collider_set.insert_with_parent(collider, rigid_body_handle, &mut rigid_body_set);
```

  </TabItem>
</Tabs>

## Collider type
There are two type of colliders: `ColliderType::Solid` and `ColliderType::Sensor`:
- **Solid colliders** are what you'd expect a collider to  be: a geometric shape that can have contact points with other
colliders to generate contact forces to prevent objects from penetrating-each-others.
- **Sensor colliders** on the other end don't generate contacts: they only generate intersection events when one sensor
collider and another collider start/stop touching. Sensor colliders are generally used to detect when something enters
an area. Solid colliders are used to have things colliding to each-other in a realistic manner.

By default a collider is a solid collider. This can be changed to a sensor when constructing the collider, or after its
construction:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the collider type when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
  .sensor(true)
  .build();
```
```rust
/* Set the collider type after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_sensor(true);
assert!(collider.is_sensor());
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the collider type when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
  .sensor(true)
  .build();
```
```rust
/* Set the collider type after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_sensor(true);
assert!(collider.is_sensor());
```

  </TabItem>
</Tabs>




## Shapes
The main characteristic of a collider is its geometric shape. The supported shapes are illustrated bellow:

![supported shapes](/img/supported_shapes.svg)

Shapes only hold information about their geometry. Their world-space position is equal to the collider's position.
Balls cuboids, capsules, cylinders, and cones are all described by their half-height and/or radius. Compound shapes,
convex meshes, triangle meshes, heightfields, and polylines are more complicated shapes described in the next paragraphs. 

### Convex meshes
A convex mesh is a shape such that: if two points are part of the shape, then the segment between these two points is
also part of the shape:

![convex versus non-convex](/img/convex_concave_crossing.svg)

There are two ways of creating a collider with a convex shape:
1. Using `ColliderBuilder::convex_hull(points)`. This is the simplest approach: it will automatically compute the convex
   hull of the given set of points. A __convex hull__ is the smallest convex shape that contains all the given points.
2. Using `ColliderBuilder::convex_mesh(points, indices)` (in 3D) or `ColliderBuilder::convex_polyline(points)` in 2D.
   This takes a mesh described by its vertex buffer and index
   buffer and assumes it is already convex (you need to ensure that it is convex). This will be more efficient that the
   `convex_hull` constructor because this won't do any calculation to ensure convexity. However, if the input mesh isn't
   actually convex, collision-detection with that shape give incorrect result.
   
### Triangle meshes
Triangle meshes can be used to describe the boundary of any kind of shape. This is generally useful to describe the
static environment in games (terrains, buildings, etc.)  Triangle meshes are defined by their vertex buffer and
their index buffer. The winding of the triangles of a triangle mesh does not matter.

:::note
A triangle mesh is composed of triangles with no thicknesses. This means that geometric queries like point-containment
test won't work as expected because the triangle mesh is assumed to have no interior.
:::

### Heightfields
### Polylines
### Compound shapes
### Round shapes
Some shapes have a __round__ variants: `RoundCuboid`, `RoundCylinder`, `RoundCone`, `RoundConvexPolygon` and
`RoundConvexPolyhedron`. These are shapes to which is added a small thickness with round border:

<p align="center">
    <img src="/img/round_cuboid.svg" alt="round cuboid"/>
</p>

:::note
For algorithmic reasons, collision-detection involving **round cylinders**, **round cones**, **round convex polygon** or
**round convex polyhedron** will be faster that collision-detection with their non-round counterparts. However,
collision-detection with **round-cuboids** will be slower than collision-detection with regular cuboids.
:::

Colliders with round shapes are built in a similar way as their non-round counterparts, e.g., `ColliderBuilder::round_cuboid`.
These constructors take one additional parameter: the size of the added thickness called `border_radius`.

### Convex decomposition
In addition to these basic shapes, colliders support **compound** shapes, i.e., shapes defined as the union of
multiple shapes. This can be useful to define a concave shape as the union of several convex shapes. In fact, this
use-case is so common that it is possible to automatically decompose a concave shape into convex parts using the
`ColliderBuilder::convex_decomposition` function. This function is based on the VHACD algorithm for the approximate
convex decomposition of a 3D triangle mesh or a 2D polyline into convex part.

## Mass properties
The [mass properties of a rigid-body](rigid_bodies#mass-properties) is computed as the sum of the mass-properties 
manually set by the user for the rigid-body, plus the mass-properties of the colliders attached to it. There are two ways to define the
mass-properties of a collider:
1. The **easiest, automatic, way**: by giving the collider a non-zero density (the default density is 1.0). This will make sure the
   mass-properties are computed automatically from the collider's shape.
2. The **manual way**: by giving an explicit mass and angular inertia to the collider.

It is recommended to use the first, density-based, approach as it will ensure the automatically-computed mass-properties
are coherent with the geometric shape. Wrong mass-properties (especially the angular inertia part) may lead to unexpected
behaviors. The second, manual, approach is usually useful when modeling real-world objects for which you already know
the real-world mass and angular inertia.

The mass-properties of a collider can only be set when the collider is created:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
let rigid_body = RigidBodyBuilder::new_dynamic();
let rigid_body_handle = rigid_body_set.insert(rigid_body);
// First option: by setting the density of the collider (or we could just leave
//               its default value 1.0).
let collider = ColliderBuilder::cuboid(1.0, 2.0, 3.0)
    .density(2.0)
    .build();
// Second option: by setting the mass-properties explicitly.
let collider = ColliderBuilder::cuboid(1.0, 2.0, 3.0)
    .mass_properties(MassProperties::new(point![0.0, 1.0], 0.5, 0.3))
    .build();
// When the collider is attached, the rigid-body's mass and angular
// inertia is automatically updated to take the collider into account.
collider_set.insert(collider, rigid_body_handle, &mut rigid_body_set);
```

  </TabItem>
  <TabItem value="3D">

```rust
let rigid_body = RigidBodyBuilder::new_dynamic();
let rigid_body_handle = rigid_body_set.insert(rigid_body);
// First option: by setting the density of the collider (or we could just leave
//               its default value 1.0).
let collider = ColliderBuilder::cuboid(1.0, 2.0, 3.0)
    .density(2.0)
    .build();
// Second option: by setting the mass-properties explicitly.
let collider = ColliderBuilder::cuboid(1.0, 2.0, 3.0)
    .mass_properties(MassProperties::new(point![0.0, 1.0, 0.0], 0.5, vector![0.3, 0.2, 0.1]))
    .build();
// When the collider is attached, the rigid-body's mass and angular
// inertia is automatically updated to take the collider into account.
collider_set.insert(collider, rigid_body_handle, &mut rigid_body_set);
```

  </TabItem>
</Tabs>

## Position
The position of a collider represents its location (translation) in 2D or 3D world-space as well as its orientation (rotation).
It translational part is represented as a vector and its rotational part as an unit quaternion (in 3D) or a unit complex
number (in 2D). Both are combined into an isometry (`Isometry2` or `Isometry3`).

:::warning
Please keep reading paragraph after the next example. It explains how the collider position (and the action of setting
its position) behaves differently when it is attached to a rigid-body.
:::

It is possible to set this position when the collider is created or after its creation:
<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the collider position when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .translation(vector![1.0, 2.0])
    .rotation(0.4)
    // Set both translation and rotation at once.
    .position(Isometry2::new(vector![1.0, 2.0], 0.4))
    .build();
```
```rust
/* Set the collider position after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_translation(vector![1.0, 2.0]);
collider.set_rotation(0.4);
// Set both the translation and rotation at once.
collider.set_position(Isometry2::new(vector![1.0, 2.0], 0.4));
assert_eq!(collider.translation(), vector![1.0, 2.0]);
assert_eq!(collider.rotation().angle(), 0.4);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the collider position when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .translation(vector![1.0, 2.0, 3.0])
    .rotation(vector![0.1, 0.2, 0.4])
    // Set both translation and rotation at once.
    .position(Isometry2::new(vector![1.0, 2.0, 3.0], vector![0.1, 0.2, 0.4]))
    .build();
```
```rust
/* Set the collider position after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_translation(vector![1.0, 2.0, 3.0]);
collider.set_rotation(vector![0.1, 0.2, 0.4]);
// Set both the translation and rotation at once.
collider.set_position(Isometry2::new(vector![1.0, 2.0, 3.0], vector![0.1, 0.2, 0.4]));
assert_eq!(collider.translation(), vector![1.0, 2.0, 3.0]);
assert_eq!(collider.rotation().scaled_axis(), vector![0.1, 0.2, 0.4]);
```

  </TabItem>
</Tabs>


If a collider is **attached to a rigid-body**, its position is automatically updated by the physics pipeline when a
rigid-body moved by the physics pipeline. If a change to the rigid-body position is made by the user then the collider
position will be updated during the next timestep.

Therefore, directly setting the position of a collider attached to a rigid-body will have **no
lasting effect**. Instead, it is possible to set the position of the collider **relative** to the rigid-body it is
attached to:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
let rigid_body = RigidBodyBuilder::new_dynamic().build();
let rigid_body_handle = rigid_body_set.insert(rigid_body);
let collider = ColliderBuilder::ball(0.5)
    .translation(vector![1.0, 2.0, 3.0])
    .build();
// Attach the collider to the rigid-body. The collider's position wrt. the rigid-body
// is automatically set to the collider current position when this method is called.
collider_set.insert(collider, rigid_body_handle, &mut rigid_body_set);
```
```rust
/* Set the collider position wrt. its parent after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_position_wrt_parent(Isometry2::translation(1.0, 2.0, 3.0));
assert_eq!(collider.position_wrt_parent().translation.vector, vector![1.0, 2.0, 3.0]);
```

  </TabItem>
  <TabItem value="3D">

```rust
let rigid_body = RigidBodyBuilder::new_dynamic().build();
let rigid_body_handle = rigid_body_set.insert(rigid_body);
let collider = ColliderBuilder::ball(0.5)
    .translation(vector![1.0, 2.0, 3.0])
    .build();
// Attach the collider to the rigid-body. The collider's position wrt. the rigid-body
// is automatically set to the collider current position when this method is called.
collider_set.insert(collider, rigid_body_handle, &mut rigid_body_set);
```
```rust
/* Set the collider position wrt. its parent after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_position_wrt_parent(Isometry3::translation(1.0, 2.0, 3.0));
assert_eq!(collider.position_wrt_parent().translation.vector, vector![1.0, 2.0, 3.0]);
```

  </TabItem>
</Tabs>


## Friction
Friction is a force that opposes the relative tangential motion between two rigid-bodies with colliders in contact.
This force has a direction orthogonal to the contact normal and opposite to the relative rigid-body motion at
the contact point. Following the Coulomb friction model, the maximum magnitude of this force is the magnitude of the
force along the contact normal multiplied by a **friction coefficient**. A friction coefficient
of 0 implies no friction at all (completely sliding contact) and a coefficient greater or equal to 1 implies an
extremely strong friction.

:::note
Rapier does not make any distinction between the static and dynamic friction coefficients currently.
:::

Each collider has its own friction coefficient. This means that when two colliders are in contact, we need to apply a
rule that combines the friction  coefficients of these two colliders into a single coefficient that will be used for
the contact. This rule is described by the `CoefficientCombineRule` enum:
- `CoefficientCombineRule::Average`: the average of the two coefficients is used for the contact.
- `CoefficientCombineRule::Min`: the minimum among the two coefficient is used for the contact.
- `CoefficientCombineRule::Multiply`: the product of the two coefficients is used for the contact.
- `CoefficientCombineRule::Max`: the maximum among the two coefficient is used for the contact.

By default, the `Average` rule is used. Each collider can be given its own combine rule. When two colliders are in
contact, we need to select one of their combine rule. The following precedence is used: `Max > Multiply > Min > Average`.

For example is one collider with the `Multiply` rule is in contact with a collider with the `Average` rule, then the
`Multiply` rule will be applied for this contact (i.e. the coefficients of both colliders will be multiplied to
obtain the coefficient used by the contact).

:::info
The `CoefficientCombineRule` system exists to cover a wide variety of use-cases efficient. If this is not flexible
enough, it is possible to get  full control over the selection of friction coefficient for each contact points using
[contact_modification](advanced_collision_detection#contact-modification). For example, contact modification allow the
simulation of colliders with non-uniform friction coefficients.
:::

The friction coefficient and friction combine rule can both be set when the collider is created or after its creation:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the friction coefficient and friction combine rule
  when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .friction(0.7)
    .friction_combine_rule(CoefficientCombineRule::Min)
    .build();
```
```rust
/* Set the friction coefficient and friction combine rule
   after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_friction(0.7);
collider.set_friction_combine_rule(CoefficientCombineRule::Min);
assert_eq!(collider.friction(), 0.7);
assert_eq!(collider.friction_combine_rule(), CoefficientCombineRule::Min);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the friction coefficient and friction combine rule
   when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .friction(0.7)
    .friction_combine_rule(CoefficientCombineRule::Min)
    .build();
```
```rust
/* Set the friction coefficient and friction combine rule
   after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_friction(0.7);
collider.set_friction_combine_rule(CoefficientCombineRule::Min);
assert_eq!(collider.friction(), 0.7);
assert_eq!(collider.friction_combine_rule(), CoefficientCombineRule::Min);
```

  </TabItem>
</Tabs>

## Restitution
Restitution controls how **elastic**, aka. __bouncy__, a contact is. Le elasticity of a contact is controlled
by the **restitution coefficient**. A restitution coefficient set to 1 (fully elastic contact) implies that the 
exit velocity at a contact is equal to the entry velocity: it's as if you drop a bouncing ball and it gets back to
the same height after it bounces). A restitution coefficient set ot 0 implies that the exit velocity at a contact will
be zero: it's as if you drop a ball but it doesn't bounce at all.

:::note
The friction and restitution coefficients are both managed in very similar ways: with the `CoefficientCombineRule`
or with contact-modification. The paragraph bellow is almost identical to the paragraph about [friction](#friction).
:::

Each collider has its own restitution coefficient. This means that when two colliders are in contact, we need to apply a
rule that combines the restitution  coefficients of these two colliders into a single coefficient that will be used for
the contact. This rule is described by the `CoefficientCombineRule` enum:
- `CoefficientCombineRule::Average`: the average of the two coefficients is used for the contact.
- `CoefficientCombineRule::Min`: the minimum among the two coefficient is used for the contact.
- `CoefficientCombineRule::Multiply`: the product of the two coefficients is used for the contact.
- `CoefficientCombineRule::Max`: the maximum among the two coefficient is used for the contact.

By default, the `Average` rule is used. Each collider can be given its own combine rule. When two colliders are in
contact, we need to select one of their combine rule. The following precedence is used: `Max > Multiply > Min > Average`.

For example is one collider with the `Multiply` rule is in contact with a collider with the `Average` rule, then the
`Multiply` rule will be applied for this contact (i.e. the coefficients of both colliders will be multiplied to
obtain the coefficient used by the contact).

:::info
The `CoefficientCombineRule` system exists to cover a wide variety of use-cases efficient. If this is not flexible
enough, it is possible to get  full control over the selection of restitution coefficient for each contact points using
[contact_modification](advanced_collision_detection#contact-modification). For example, contact modification allow the
simulation of colliders with non-uniform restitution coefficients.
:::

The restitution coefficient and restitution combine rule can both be set when the collider is created or after its creation:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the restitution coefficient and restitution combine rule
  when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .restitution(0.7)
    .restitution_combine_rule(CoefficientCombineRule::Min)
    .build();
```
```rust
/* Set the restitution coefficient and restitution combine rule
   after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_restitution(0.7);
collider.set_restitution_combine_rule(CoefficientCombineRule::Min);
assert_eq!(collider.restitution(), 0.7);
assert_eq!(collider.restitution_combine_rule(), CoefficientCombineRule::Min);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the restitution coefficient and restitution combine rule
   when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .restitution(0.7)
    .restitution_combine_rule(CoefficientCombineRule::Min)
    .build();
```
```rust
/* Set the restitution coefficient and restitution combine rule
   after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_restitution(0.7);
collider.set_restitution_combine_rule(CoefficientCombineRule::Min);
assert_eq!(collider.restitution(), 0.7);
assert_eq!(collider.restitution_combine_rule(), CoefficientCombineRule::Min);
```

  </TabItem>
</Tabs>


## Collision groups and solver groups
The most efficient way of preventing some pairs of collisions from interacting with each other is to use collision
groups or solver groups. Each collider can be:
- A `collision_groups` for filtering what pair of colliders should have their contacts (or intersection test if
  at least one of the colliders is a sensor) computed by the narrow-phase.
  This filtering happens right after the broad-phase, before the narrow phase.
- A `solver_groups` for filtering what pair of colliders should have their contact forces computed. This filtering
  happens right after the narrow-phase, before the constraints solver

In other words, the `solver_groups` is here to prevent contacts forces from happening between some colliders, whereas the
`collision_groups` will also prevent the contact themselves (and contact events) from being computed. The
`collision_groups` should be preferred most of the time because it skips more computations. The `solver_groups` is only
useful if you really want the contact information to be computed, for example so that you can apply your own forces based
on these contacts.

A collision group or solver group is described as a pair of bit masks:
- The groups **membership** indicates what groups the collider is part of (one bit per group).
- The groups **filter** indicates what groups the collider can interact with (one bit per group).

:::info
Because the `membership` and `filter` bit masks are `u32` there is a total of 32 groups. By default all bits are set to
1: the collider is part of every group, and can interact with every group.
:::

For example, let's say we want our collider `A` to be part of the groups `[0, 2, 3]` and to be able to interact
with the groups `[2]`, then its groups membership is `0b1101` and its groups filter is `0.0100`. The collision groups
and solver groups of a collider can be set during or after its creation:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the restitution coefficient and restitution combine rule
  when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .collision_groups(InteractionGroups::new(0b1101, 0b0100))
    .solver_groups(InteractionGroups::new(0b0011, 0b1011))
    .build();
```
```rust
/* Set the restitution coefficient and restitution combine rule
   after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_collision_groups(InteractionGroups::new(0b1101, 0b0100));
collider.set_solver_groups(InteractionGroups::new(0b0011, 0b1011));
assert_eq!(collider.collision_groups(), InteractionGroups::new(0b1101, 0b0100));
assert_eq!(collider.solver_groups(), InteractionGroups::new(0b0011, 0b1011));
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the restitution coefficient and restitution combine rule
  when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
    .collision_groups(InteractionGroups::new(0b1101, 0b0100))
    .solver_groups(InteractionGroups::new(0b0011, 0b1011))
    .build();
```
```rust
/* Set the restitution coefficient and restitution combine rule
   after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.set_collision_groups(InteractionGroups::new(0b1101, 0b0100));
collider.set_solver_groups(InteractionGroups::new(0b0011, 0b1011));
assert_eq!(collider.collision_groups(), InteractionGroups::new(0b1101, 0b0100));
assert_eq!(collider.solver_groups(), InteractionGroups::new(0b0011, 0b1011));
```

  </TabItem>
</Tabs>


After the broad-phase detects that two colliders `A` and `B` may start being in contact, the narrow-phase will check the collision
groups of both colliders to see if it needs to compute contacts. The check operates as follows:
- If the collider `A` is not member of any collision group in the filter of `B`, then no contact is computed.
- If the collider `B` is not member of any collision group in the filter of `A`, then no contact is computed.
- The exact bit-wise check is the following:
  
```rust
   (A.collision_groups().memberships & B.collision_groups().filter) != 0
&& (B.collision_groups().memberships & A.collision_groups().filter) != 0
```

If this test succeeds, then the narrow-phase will compute the contacts. Then it will check the solver groups of both
colliders, using the same kind of tests as described before but using the `solver_groups` instead of `collision_groups`.
If the test succeeds then the constraints solver will compute forces for these contacts. Otherwise, it won't.

## Contact and intersection events
The narrow-phase can generate two types of events: [contact events](#contact-events) between two non-sensor colliders
or [intersection events](#intersection-events) between one sensor collider and another collider. In order to handle
these events, it is necessary to collect them using a structure implementing the `EventHandler` trait.
Because **Rapier** can be paralellized, this event handler must also implement `Send + Sync`.

One such structure provided by `Rapier` is the `rapier::pipeline::ChannelEventCollector`. This event collector contains
channels from the [crossbeam crate](https://crates.io/crates/crossbeam). These channels will be populated with events
during each called to `PhysicsPipeline::step`:


<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
// Initialize the event collector.
let (contact_send, contact_recv) = crossbeam::channel::unbounded();
let (intersection_send, intersection_recv) = crossbeam::channel::unbounded();
let event_handler = ChannelEventCollector::new(intersection_send, contact_send);

physics_pipeline.step(
    &gravity,
    &integration_parameters,
    &mut island_manager,
    &mut broad_phase,
    &mut narrow_phase,
    &mut rigid_body_set,
    &mut collider_set,
    &mut joint_set,
    &mut ccd_solver,
    &physics_hooks,
    &event_handler
);

while let Ok(intersection_event) = intersection_recv.try_recv() {
// Handle the intersection event.
}

while let Ok(contact_event) = contact_recv.try_recv() {
// Handle the contact event.
}
```

  </TabItem>
  <TabItem value="3D">

```rust
// Initialize the event collector.
let (contact_send, contact_recv) = crossbeam::channel::unbounded();
let (intersection_send, intersection_recv) = crossbeam::channel::unbounded();
let event_handler = ChannelEventCollector::new(intersection_send, contact_send);

pipeline.step(
    &gravity,
    &integration_parameters,
    &mut island_manager,
    &mut broad_phase,
    &mut narrow_phase,
    &mut bodies,
    &mut colliders,
    &mut joints,
    &mut ccd_solver,
    &physics_hooks,
    &event_handler
);

while let Ok(intersection_event) = intersection_recv.try_recv() {
    // Handle the intersection event.
}

while let Ok(contact_event) = contact_recv.try_recv() {
    // Handle the contact event.
}
```

  </TabItem>
</Tabs>

:::info
Contact and intersection events identify the involved colliders by their handle. It is possible to retrieve the handle of
the body a collider is attached to: `colliders.get(collider_handle).unwrap().parent()`.
:::

### Intersection events
Intersection events are triggered when two colliders (with at least one of them being a sensor) transition between
intersecting or not. One intersection event has the type `ProximityEvent`:

| Field         | Description |
|--             | --          |
| `collider1`   | The handle of the first collider involved in the intersection. |
| `collider2`   | The handle of the second collider involved in the intersection. |
| `intersecting` | Set to `true` if the colliders shapes are intersecting. |

### Contact events
Contact events are triggered when two non-sensor colliders transition between having zero contact points and having 
at least one contact point.  Transitioning between having one contact point to having more than one contact points is
not reported.  The `ContactEvent` enum has two variants:

1. `ContactEvent::Started(h1, h2)` to indicate the transition between
   0 to at least one contact point.
2. `ContactEvent::Stopped(h1, h2)` to indicate the transition between
   at least one contact point to 0.

Here `h1` and `h2` identify the handles of the colliders involved in the contact.

## User-data
Each collider can be given a user-defined data of type `u128`. This integer can have any value
and is never used/modified by the physics-engine. This can for example be useful to add some custom data for personalized
[contact filtering/modification](advanced_collision_detection).

This user-data can be set when the collider is created or after its creation:
<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the user-data when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
  .user_data(42)
  .build();
```
```rust
/* Set the user-data after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.user_data = 42;
assert_eq!(collider.user_data, 42);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the user-data when the collider is created. */
let collider = ColliderBuilder::ball(0.5)
  .user_data(42)
  .build();
```
```rust
/* Set the user-data after the collider creation. */
let collider = collider_set.get_mut(collider_handle).unwrap();
collider.user_data = 42;
assert_eq!(collider.user_data, 42);
```

  </TabItem>
</Tabs>

