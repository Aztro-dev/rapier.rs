---
id: rigid_bodies
title: Rigid-bodies
sidebar_label: Rigid-bodies
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The real-time simulation of rigid-bodies subjected to forces and contacts is the main feature of a physics engine for
video-games, robotics, or animation. Rigid-bodies are typically used to simulate the dynamics of non-deformable solids as well
as to integrate the trajectory of solids which velocities are controlled by the user (e.g. moving platforms). On
the other hand, rigid-bodies are not enough to simulate, e.g., cars, ragdolls, or robotic systems, as those use-cases
require adding restrictions on the relative motion between their parts with [joints](joints).
 
Note that rigid-bodies are only responsible for the dynamics of the solid. [Colliders](colliders) can be attached to a
rigid-body to specify its shape and enable collision-detection. A rigid-body without collider attached to it will
not be affected by contacts (because there is no shape to compute contact against).

## Creation and insertion
A rigid-body is created by a `RigidBodyBuilder` structure that is based on the builder pattern. Then it needs
to be inserted into the `RigidBodySet` that will be processed by the physics-pipeline or query-pipeline.

:::info
The following example shows most setters that can be called to customize the
rigid-body being built. The input values are just random so using this example
as-is will not lead to a useful result.
:::

<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
use rapier2d::na::{vector, Isometry2};
use rapier2d::dynamics::{BodyStatus, RigidBodyBuilder, RigidBodySet};

// The set that will contain our rigid-bodies.
let mut rigid_body_set = RigidBodySet::new();

// Builder for a static rigid-body.
let _ = RigidBodyBuilder::new_static();
// Builder for a dynamic rigid-body.
let _ = RigidBodyBuilder::new_dynamic();
// Builder for a kinematic rigid-body.
let _ = RigidBodyBuilder::new_kinematic();
// Builder for a body with a status specified by an enum.
let rigid_body = RigidBodyBuilder::new(BodyStatus::Dynamic)
    // The rigid body translation.
    // Default: zero vector.
    .translation(vector![0.0, 5.0])
    // The rigid body rotation.
    // Default: no rotation.
    .rotation(5.0)
    // The rigid body position. Will override `.translation(...)` and `.rotation(...)`.
    // Default: the identity isometry.
    .position(Isometry2::new(vector![1.0, 2.0], 0.4))
    // The linear velocity of this body.
    // Default: zero velocity.
    .linvel(vector![1.0, 2.0])
    // The angular velocity of this body.
    // Default: zero velocity.
    .angvel(2.0)
    // The scaling factor applied to the gravity affecting the rigid-body.
    // Default: 1.0
    .gravity_scale(0.5)
    // Whether or not this body can sleep.
    // Default: true
    .can_sleep(true)
    // Whether or not CCD is enabled for this rigid-body.
    // Default: false
    .ccd_enabled(false)
    // All done, actually build the rigid-body.
    .build();

// Insert the rigid-body into the set.
let handle = rigid_body_set.insert(rigid_body);
```

  </TabItem>
  <TabItem value="3D">

```rust
use rapier3d::na::{vector, Isometry3};
use rapier3d::dynamics::{BodyStatus, RigidBodyBuilder, RigidBodySet};

// The set that will contain our rigid-bodies.
let mut rigid_body_set = RigidBodySet::new();

// Builder for a static rigid-body.
let _ = RigidBodyBuilder::new_static();
// Builder for a dynamic rigid-body.
let _ = RigidBodyBuilder::new_dynamic();
// Builder for a kinematic rigid-body.
let _ = RigidBodyBuilder::new_kinematic();
// Builder for a body with a status specified by an enum.
let rigid_body = RigidBodyBuilder::new(BodyStatus::Dynamic)
    // The rigid body translation.
    // Default: zero vector.
    .translation(vector![0.0, 5.0, 1.0])
    // The rigid body rotation.
    // Default: no rotation.
    .rotation(vector![0.0, 0.0, 5.0])
    // The rigid body position. Will override `.translation(...)` and `.rotation(...)`.
    // Default: the identity isometry.
    .position(Isometry3::new(vector![1.0, 3.0, 2.0], vector![0.0, 0.0, 0.4]))
    // The linear velocity of this body.
    // Default: zero velocity.
    .linvel(vector![1.0, 3.0, 4.0])
    // The angular velocity of this body.
    // Default: zero velocity.
    .angvel(vector![3.0, 0.0, 1.0])
    // The scaling factor applied to the gravity affecting the rigid-body.
    // Default: 1.0
    .gravity_scale(0.5)
    // Whether or not this body can sleep.
    // Default: true
    .can_sleep(true)
    // Whether or not CCD is enabled for this rigid-body.
    // Default: false
    .ccd_enabled(false)
    // All done, actually build the rigid-body.
    .build();

// Insert the rigid-body into the set.
let handle = rigid_body_set.insert(rigid_body);
```

  </TabItem>
</Tabs>


All the properties are optional. The only calls that are required are `RigidBodyBuilder::new(status)`,
`RigidBodyBuilder::new_static()`, `RigidBodyBuilder::new_dynamic()`, or `RigidBodyBuilder::new_kinematic()`, to
initialize the builder, and `.build()` to actually build the rigid body.

Typically, the inertia and center of mass are automatically set to the inertia and center of mass resulting from the
shapes of the [colliders](#colliders) attached to the rigid-body. But it can also be set manually.

## Rigid-body type
There are three types of rigid-bodies, identified by the `RigidBodyType` enumeration:

* **`RigidBodyType::Dynamic`:** It indicates the body is affected by external forces and contacts.
* **`RigidBodyType::Static`:** Indicates the body cannot move. It acts as if it has an infinite mass and will not be
    affected by any force. It will continue to collide with dynamic bodies but not with static nor with kinematic
    bodies. This is typically used for the ground or for temporarily freezing a body.
* **`RigidBodyType::Kinematic`:** Indicates that the body position must not be altered by the physics engine. The user is
    free to set its next position and the body velocity will be deduced at each update accordingly to ensure a realistic
    behavior of dynamic bodies in contact with it. This is typically used for moving **platforms**, **elevators**, etc.

## Position
The position of a rigid-body represents its location (translation) in 2D or 3D world-space, as well as its orientation (rotation).
It translational part is represented as a vector and its rotational part as an unit quaternion (in 3D) or a unit complex
number (in 2D). Both are combined into an isometry (`Isometry2` or `Isometry3`).

The position of a rigid-body can be set when creating it. It can also be set after
its creation as illustrated bellow.

:::warning
Directly changing the position of a rigid-body is equivalent to teleporting it: this is a not a
physically realistic action! Teleporting a dynamic or kinematic bodies may result in odd behaviors
especially if it teleports into a space occupied by other objects. For dynamic bodies, [forces,
impulses](#forces-and-impulses), or [velocity modification](#velocity) should be preferred.
For kinematic bodies, see the discussion after the examples bellow.
:::

<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
/* Set the position when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    // The rigid body translation.
    // Default: zero vector.
    .translation(vector![0.0, 5.0])
    // The rigid body rotation.
    // Default: no rotation.
    .rotation(5.0)
    // The rigid body position. Will override `.translation(...)` and `.rotation(...)`.
    // Default: the identity isometry.
    .position(Isometry2::new(vector![1.0, 2.0], 0.4))
    // All done, actually build the rigid-body.
    .build();
```
```rust
/* Set the position after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_translation(vector![0.0, 5.0]), true);
rigid_body.set_rotation(0.2, true);
assert_eq!(rigid_body.translation(), vector![0.0, 5.0]);
assert_eq!(rigid_body.rotation().angle(), 0.2);

rigid_body.set_position(Isometry2::new(vector![1.0, 2.0], 0.4), true);
assert_eq!(rigid_body.position(), Isometry2::new(vector![1.0, 2.0], 0.4));
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the position when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    // The rigid body translation.
    // Default: zero vector.
    .translation(vector![0.0, 5.0, 1.0])
    // The rigid body rotation.
    // Default: no rotation.
    .rotation(vector![0.2, 0.0, 0.0])
    // The rigid body position. Will override `.translation(...)` and `.rotation(...)`.
    // Default: the identity isometry.
    .position(Isometry3::new(vector![1.0, 2.0, 3.0], vector![0.2, 0.0, 0.0]))
    // All done, actually build the rigid-body.
    .build();
```
```rust
/* Set the position after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_translation(vector![0.0, 5.0, 1.0]), true);
rigid_body.set_rotation(vector![0.2, 0.0, 0.0], true);
assert_eq!(rigid_body.translation(), vector![0.0, 5.0, 1.0]);
assert_eq!(rigid_body.rotation().scaled_axis(), vector![0.2, 0.0, 0.0]);

rigid_body.set_position(Isometry3::new(vector![1.0, 2.0, 3.0], vector![0.0, 0.4, 0.0]), true);
assert_eq!(rigid_body.position(), Isometry3::new(vector![1.0, 2.0, 3.0], vector![0.0, 0.4, 0.0]));
```

  </TabItem>
</Tabs>


In order to move a dynamic it is strongly discouraged to set its position directly as it
may results in weird behaviors: it's as if the rigid-body teleports itself, which is a non-physical behavior. For dynamic
bodies, it is recommended to either set its [velocity](#velocity) or to apply [forces or impulses](#forces-and-impulses).


For kinematic bodies, it is recommended to use the special methods:
- `RigidBody::set_next_kinematic_position`
- `RigidBody::set_next_kinematic_rotation`
- `RigidBody::set_next_kinematic_translation`

These methods will let the physics pipeline compute the fictitious velocity of the kinematic body for more realistic
interactions with other rigid-bodies. These methods won't modify the position of the kinematic body itself. The
position of the kinematic body will be automatically set to these values during the next physics pipeline update.

## Velocity
The velocity of a dynamic rigid-body controls how fast it is moving in time. The velocity is applied at the **center-of-mass**
 of the rigid-body, and is composed of two independent parts:
1. The **linear velocity** is specified as a vector representing the direction an magnitude of the movement.
2. In 3D, the **angular velocity** is given as a vector representing the rotation
axis multiplied by the the rotation angular speed in `rad/s` (axis-angle representation). In 2D, the **angular velocity** is
given as a real representing the angular speed in `rad/s`.

:::info
The velocity is only relevant to **dynamic** rigid-bodies. It has not effect on static rigid-bodies and the
velocity of kinematic rigid-bodies are automatically computed at each timestep.
:::

The velocity of a rigid-body is automatically updated by the physics pipeline to take forces, contacts,
and joints into account. It can be set when the rigid-body is created or after its creation:
<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
/* Set the velocities when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    // The linear velocity of this body.
    // Default: zero velocity.
    .linvel(vector![1.0, 3.0])
    // The angular velocity of this body.
    // Default: zero velocity.
    .angvel(3.0)
    // All done, actually build the rigid-body.
    .build();
```
```rust
/* Set the velocities after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_linvel(vector![1.0, 3.0]), true);
rigid_body.set_angvel(3.0, true);
assert_eq!(rigid_body.linvel(), vector![1.0, 3.0]);
assert_eq!(rigid_body.angvel(), 3.0);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the velocities when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    // The linear velocity of this body.
    // Default: zero velocity.
    .linvel(vector![1.0, 3.0, 4.0])
    // The angular velocity of this body.
    // Default: zero velocity.
    .angvel(vector![3.0, 0.0, 0.0])
    // All done, actually build the rigid-body.
    .build();
```
```rust
/* Set the velocities after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_linvel(vector![1.0, 3.0, 4.0], true);
rigid_body.set_angvel(vector![3.0, 0.0, 0.0], true);
assert_eq!(rigid_body.linvel(), vector![1.0, 3.0, 4.0]);
assert_eq!(rigid_body.angvel(), vector![3.0, 0.0, 0.0]);
```

  </TabItem>
</Tabs>

Alternatively, the velocity of a rigid-body can be altered indirectly by applying a force or an impulse
in the rigid-body (see the [section about forces](#forces)).

## Gravity
Gravity is such a common force that it is implemented as a special case (even if it could easily be implemented
by the user using force application). The gravity is given as an argument to the `PhysicsPipeline::step` method and can be
modified at will by simply modifying that argument. Note however that a change of gravity won't automatically wake-up
the [sleeping bodies](#sleeping) so keep in mind that you may want to wake them up before a gravity change.

Because static and kinematic bodies are immune to forces, they are not affected by gravity.

:::info
A rigid-body with no mass will not be affected by gravity either. So if your rigid-body
doesn't fall when you expected it to, make sure it has a mass set explicitly, or has at least one collider with
non-zero density attached to it.
:::

It is possible to change the way gravity affects a specific rigid-body by setting the rigid-body's **gravity scale**
to a value other than `1`. The magnitude of the gravity applied to this body will be multiplied by this scaling
factor. Therefore, a gravity scale set to `0` will disable gravity for the rigid-body whereas a gravity scale set to
`2` will make it twice as strong. A negative value will flip the direction of the gravity.

This gravity scale factor can be set when the rigid-body is created or after its creation:
<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
/* Set the gravity scale when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    // Divide by 2 the strength of gravity for this rigid-body.
    .gravity_scale(0.5)
    .build();
```
```rust
/* Set the gravity scale after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_gravity_scale(0.5, true);
assert_eq!(rigid_body.gravity_scale(), 0.5);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the gravity scale when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    // Divide by 2 the strength of gravity for this rigid-body.
    .gravity_scale(0.5)
    .build();
```
```rust
/* Set the gravity scale after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_gravity_scale(0.5, true);
assert_eq!(rigid_body.gravity_scale(), 0.5);
```

  </TabItem>
</Tabs>


## Forces and impulses
In addition to [gravity](#gravity), it is possible to apply custom forces and impluses to dynamic rigid-bodies in order
to make  them move in specific ways. Forces affect the rigid-body's acceleration whereas impulses affect the
rigid-body's velocity using the familiar equations:
- **Forces:** acceleration changes is equal to the force divided by the mass: $\Delta{}a = m^{-1}f$
- **Impulses:** velocity change is equal to the impulse divided by the mass: $\Delta{}v = m^{-1}i$

Forces and impulses can be applied to a rigid-body after it has been created:
<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();

// The `true` argument makes sure the rigid-body is awake.
rigid_body.apply_force(vector![0.0, 1000.0], true);
rigid_body.apply_torque(100.0, true);
rigid_body.apply_force_at_point(vector![0.0, 1000.0], point![1.0, 2.0], true);

rigid_body.apply_impulse(vector![0.0, 1000.0], true);
rigid_body.apply_torque_impulse(100.0, true);
rigid_body.apply_impulse_at_point(vector![0.0, 1000.0], point![1.0, 2.0], true);
```

  </TabItem>
  <TabItem value="3D">

```rust
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();

// The `true` argument makes sure the rigid-body is awake.
rigid_body.apply_force(vector![0.0, 1000.0, 0.0], true);
rigid_body.apply_torque(vector![100.0, 0.0, 0.0], true);
rigid_body.apply_force_at_point(vector![0.0, 1000.0, 0.0], point![1.0, 2.0, 3.0], true);

rigid_body.apply_impulse(vector![0.0, 1000.0, 0.0], true);
rigid_body.apply_torque_impulse(vector![100.0, 0.0, 0.0], true);
rigid_body.apply_impulse_at_point(vector![0.0, 1000.0, 0.0], point![1.0, 2.0, 3.0], true);
```

  </TabItem>
</Tabs>

:::info
Keep in mind that a rigid-body with  a zero mass won't be affected by a linear force/impulse, and a rigid-body with a zero
angular inertia won't be affected by angular forces/impulses. So if your force doesn't appear to do anything, make sure that:
1. It is strong enough to make the rigid-body move (try a very large value and see if it does something).
2. The rigid-body is dynamic and awake (by setting the last `wake_up` parameter to `true`).
3. The rigid-body has a non-zero mass or angular inertia either because they were set explicitly, or because they
   were computed automatically from colliders with non-zero densities.
:::

## Mass properties
The mass properties of a rigid-body is composed of three parts:
- The **mass** which determines the resistance of the rigid-body wrt. linear movements. A high mass implies that
  larger forces are needed to make the rigid-body move.
- The **angular inertia** which determines the resistance of the rigid-body wrt. the angular movements. A high angular
  inertia implies that larger torques are needed to make the rigid-body rotate.
- The **center-of-mass** which determines relative to what points torques are applied to the rigid-body.  

:::note
Zero is a special value for masses and angular inertias. A mass equal to zero is interpreted as an infinite mass.
An angular inertia equal to zero is interpreted as an infinite angular inertia. Therefore, a rigid-body with a
mass equal to zero will not be affected by any force, and a rigid-body with an angular inertia equal to zero will
not be affected by any torque.
:::

Computing the mass and angular-inertia can often be difficult because they depend on the geometric shape of the
object being simulated. This is why they are automatically computed by Rapier when a [collider](#collider) is
attached to the rigid-body: the collider add its own mass and angular-inertia contribution (computed from the
collider's density) to the rigid-body it is attached to:

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
let rigid_body = RigidBodyBuilder::new_dynamic();
let rigid_body_handle = rigid_body_set.insert(rigid_body);
// The default density is 1.0, we are setting 2.0 for this example.
let collider = ColliderBuilder::cuboid(1.0, 2.0).density(2.0).build();
// When the collider is attached, the rigid-body's mass and angular
// inertia is automatically updated to take the collider into account.
collider_set.insert(collider, rigid_body_handle, &mut rigid_body_set);
```

  </TabItem>
  <TabItem value="3D">

```rust
let rigid_body = RigidBodyBuilder::new_dynamic();
let rigid_body_handle = rigid_body_set.insert(rigid_body);
// The default density is 1.0, we are setting 2.0 for this example.
let collider = ColliderBuilder::cuboid(1.0, 2.0, 3.0).density(2.0).build();
// When the collider is attached, the rigid-body's mass and angular
// inertia is automatically updated to take the collider into account.
collider_set.insert(collider, rigid_body_handle, &mut rigid_body_set);
```

  </TabItem>
</Tabs>

Alternatively, it is possible to set the mass properties of a rigid-body when it's created. Keep in mind that
this won't prevent the colliders' contributions to be added to these values. So make sure to set the attached
colliders' densities to zero if you want your explicit values to be the final mass-properties values.

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Set the mass-properties when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .additional_mass(0.5)
    .additional_principal_angular_inertia(0.3)
    // Sets both the mass and angular inertia at once.
    .additional_mass_properties(MassProperties::new(point![0.0, 1.0], 0.5, 0.3))
    .build();
```
```rust
/* Set the mass-properties after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_mass_properties(MassProperties::new(point![0.0, 1.0], 0.5, 0.3), true);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the mass-properties when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .additional_mass(0.5)
    .additional_principal_angular_inertia(vector![0.3, 0.2, 0.1])
    // Sets both the mass and angular inertia at once.
    .additional_mass_properties(MassProperties::new(point![0.0, 1.0, 0.0], 0.5, vector![0.3, 0.2, 0.1]))
    .build();
```
```rust
/* Set the mass-properties after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The `true` argument makes sure the rigid-body is awake.
rigid_body.set_mass_properties(MassProperties::new(point![0.0, 1.0, 0.0], 0.5, vector![0.3, 0.2, 0.1]), true);
```

  </TabItem>
</Tabs>

## Locking translations/rotations
It is sometimes useful to prevent a rigid-body from rotating or translating. One typical use-case for locking rotations
is to prevent a player modeled as a dynamic rigid-body from tilting. These kind of degree-of-freedom restrictions can
be achieved by [joints](#joints) but locking translations/rotations of a single rigid-body wrt. the cartesian coordinate
axes can be done  in a much more efficient and numerically stable way. That's why rigid-bodies have dedicated methods
for this.

<Tabs
groupId="dim"
defaultValue="2D"
values={[
{label: 'Example 2D', value: '2D'},
{label: 'Example 3D', value: '3D'},
]}>
<TabItem value="2D">

```rust
/* Lock translations/rotations when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .lock_translations() // prevent translations along along all axes.
    .lock_rotations()    // prevent rotations.
    .build();
```

```rust
/* Lock translations/rotations after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The last `true` argument makes sure the rigid-body is awake.
rigid_body.lock_translations(true, true);
rigid_body.lock_rotations(true, true);
```


  </TabItem>
  <TabItem value="3D">

```rust
/* Lock translations/rotations when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .lock_translations() // prevent translations along along all axes.
    .lock_rotations()    // prevent rotations along all axes.
    .restrict_rotations(true, false, false) // prevent rotations along the Y and Z axes.
    .build();
```

```rust
/* Lock translations/rotations after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
// The last `true` argument makes sure the rigid-body is awake.
rigid_body.lock_translations(true, true);
rigid_body.lock_rotations(true, true);
rigid_body.restrict_rotations(true, false, false, true);
```

  </TabItem>
</Tabs>


## Damping
Damping lets you slow down a rigid-body automatically. This can be used to achieve a wide variety of effects like
fake air friction. Each rigid-body is given a **linear damping coefficient** (affecting its linear velocity) and an
**angular damping coefficient** (affecting its angular velocity). Larger values of the damping coefficients lead to
a stronger slow-downs. Its default value is `0.0` (no damping at all).


This damping coefficients can be set when the rigid-body is created or after its creation:
<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
/* Set the damping coefficients when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .linear_damping(0.5)
    .angular_damping(1.0)
    .build();
```
```rust
/* Set the damping coefficients after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.set_linear_damping(0.5);
rigid_body.set_angular_damping(1.0);
assert_eq!(rigid_body.linear_damping(), 0.5);
assert_eq!(rigid_body.angular_damping(), 1.0);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the damping coefficients when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .linear_damping(0.5)
    .angular_damping(1.0)
    .build();
```
```rust
/* Set the damping coefficients after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.set_linear_damping(0.5);
rigid_body.set_angular_damping(1.0);
assert_eq!(rigid_body.linear_damping(), 0.5);
assert_eq!(rigid_body.angular_damping(), 1.0);
```

  </TabItem>
</Tabs>

## Dominance
Dominance is a non-realistic, but sometimes useful, feature. It can be used to make one rigid-body immune to forces
originating from contacts with some other specific bodies. For example this can let us model a player represented as a
ynamic rigid-body that cannot be "pushed back" by any, or some, other dynamic rigid-bodies part of the environment.


Each rigid-body is part of a dominance group in `[-127; 127]` (the default is 0). If the colliders from two rigid-body
are in contact, the one with the highest dominance will act as if it has an infinite mass, making it immune to the
contact forces the other body would apply on it. If both bodies are part of the same dominance group, then their
contacts will work in the usual way (both are affected by opposite forces with the same magnitude).

For example, if a dynamic body `A` is in the dominance group 10, and a dynamic body `B` in the dominance group -20, then
a contact between a collider attached to `A` and a collider attached B will result in `A` remaining immobile and B being
pushed by A.

A non-dynamic rigid-body is always considered as being part of a dominance group greater than any dynamic rigid-body.
This means that dynamic/static and dynamic/kinematic contacts will continue to work normally, independently from the
dominance group they were given by the user.

This dominance group can be set when the rigid-body is created or after its creation:
<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
/* Set the dominance group when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .dominance_group(10)
    .build();
```
```rust
/* Set the dominance group after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.set_dominance_group(10);
assert_eq!(rigid_body.dominance_group(), 10);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the dominance group when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .dominance_group(10)
    .build();
```
```rust
/* Set the dominance group after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.set_dominance_group(10);
assert_eq!(rigid_body.dominance_group(), 10);
```

  </TabItem>
</Tabs>

## Continuous collision detection
Continuous Collision Detection (CCD) is used to make sure that fast-moving objects don't miss any contacts (a problem
usually called "tunneling"). This  is done by using motion-clamping, i.e., each fast-moving rigid-body with CCD enabled
will be stopped at the time where their first contact happen, assuming they have a continuous motion. This will result
in some "time loss" for that rigid-body. This loss of time can be reduced by increasing the maximum number of CCD
substeps executed (the default being 1).

Rapier implements nonlinear CCD, meaning that it takes into account both the angular and translational motion of the
rigid-body.

:::info
CCD takes action only if the CCD-enabled rigid-body is moving too fast relative to another rigid-body. Therefore
it is useless to enable CCD on static rigid-bodies and rigid-bodies that are expected to move slowly.
:::

By default, CCD is disabled for all the rigid-bodies. It can be enabled when creating a rigid-body or after its creation:
<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
  {label: 'Example 2D', value: '2D'},
  {label: 'Example 3D', value: '3D'},
  ]}>
<TabItem value="2D">

```rust
/* Enable CCD when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .ccd_enabled(true)
    .build();
```
```rust
/* Enable CCD after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.enable_ccd(true);
assert_eq!(rigid_body.is_ccd_enabled(), true);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Enable CCD when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
    .ccd_enabled(true)
    .build();
```
```rust
/* Enable CCD after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.enable_ccd(true);
assert_eq!(rigid_body.is_ccd_enabled(), true);
```

  </TabItem>
</Tabs>



The number of substeps executed by the CCD can be modified by setting the `IntegrationParameters::max_ccd_substeps`
field.

## Sleeping
When a dynamic rigid-body doesn't move (or moves very slowly) during a few seconds, it will be marked as **sleeping**
by the physics pipeline. Rigid-bodies marked as sleeping are no longer simulated by
the physics engine until they are woken up. They are woken up automatically whenever another non-sleeping rigid-body
starts interacting with them (either with a joint, or with one of its attached collider generating contacts). That
way the physics engine doesn't waste any computational resources simulating objects that don't actually move.

However, a sleeping rigid-body won't respond to any user action. This is why it is possible to wake-up the rigid-body
manually with `RigidBody::wake_up`. Some rigid-body methods take an additional `wake_up` boolean argument that, if
true, ensures that the rigid-body wakes up before the action takes place. For example:
- `RigidBody::apply_force(force, true)` will wake-up the rigid-body before applying the force.
- `ColliderSet::remove(..., true)` will wake-up the rigid-body the removed collider is attached to.
- `JointSet::remove(..., true)` will wake-up the two rigid-bodies attached by the removed joints.

Unless you want to achieve special effects, it is recommended to always set the `wake_up` argument to `true`.
One example of case where setting the argument of `wake_up` to `false` makes sense is to simulate a custom
constant gravity with `RigidBody::apply_force(force, false)`. This will result in the force being applied
to the rigid-body, but will allow the rigid-body to fall asleep if it reaches a dynamic equilibrium (which is
OK because the gravity field is constant).

## User-data
Each rigid-body can be given a user-defined data of type `u128`. This integer can have any value
and is never used/modified by the physics-engine. This can for example be useful to add some custom data for
personalized [contact filtering/modification](advanced_collision_detection).

This user-data can be set when the rigid-body is created or after its creation:
<Tabs
  groupId="dim"
  defaultValue="2D"
  values={[
    {label: 'Example 2D', value: '2D'},
    {label: 'Example 3D', value: '3D'},
  ]}>
  <TabItem value="2D">

```rust
/* Set the user-data when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
  .user_data(42)
  .build();
```
```rust
/* Set the user-data after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.user_data = 42;
assert_eq!(rigid_body.user_data, 42);
```

  </TabItem>
  <TabItem value="3D">

```rust
/* Set the user-data when the rigid-body is created. */
let rigid_body = RigidBodyBuilder::new_dynamic()
  .user_data(42)
  .build();
```
```rust
/* Set the user-data after the rigid-body creation. */
let rigid_body = rigid_body_set.get_mut(rigid_body_handle).unwrap();
rigid_body.user_data = 42;
assert_eq!(rigid_body.user_data, 42);
```

  </TabItem>
</Tabs>

